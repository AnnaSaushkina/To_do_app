Реализованные функции:

- [x] Базовые CRUD-операции
- [x] Архитектурное ядро: создание и управление задачами
- [x] Структура данных для хранения задач

---

**В разработке:**

### **1. Базовый функционал (DOM + ООП)**

- [ ] Интеграция с DOM

1. **Работа с DOM**  
   **Что изучить:**

- Поиск элементов: `getElementById`, `querySelector`, `querySelectorAll`
- Создание элементов: `createElement`, `appendChild`, `insertAdjacentHTML`
- Манипуляции: `innerHTML`, `textContent`, `classList`, `dataset`
- Удаление элементов: `removeChild`, `remove`

**Практические задачи:**

1. Создать `<div>` и добавить его в DOM.
2. Найти все кнопки в документе и изменить их цвет.
3. Создать список `<ul>` с задачами из массива.

---

### 2. **ООП в JavaScript**

**Что изучить:**

- Конструкторы объектов vs Классы (ES6)
- Методы объектов, `this` контекст
- Паттерн **MVC** (разделение на Model, View, Controller)

**Почему классы лучше конструкторов?**

- Более читаемый синтаксис
- Наследование через `extends`
- Приватные поля (`#privateField`)

**Практические задачи:**

1. Создать объект `Task` через конструктор и класс. Сравнить подходы.
2. Реализовать `TaskManager` с методами `addTask`, `removeTask`.

---

### 3. **Делегирование событий**

**Что изучить:**

- `addEventListener`
- Объект события (`event.target`, `event.currentTarget`)
- Паттерн **делегирования** (обработка событий на родителе)

**Практические задачи:**

1. Повесить обработчик на `<ul>`, чтобы клик по любому `<li>` выводил его текст.
2. Реализовать удаление задачи по клику на кнопку внутри нее.

---

### 4. **Шаблонизация HTML**

**Что изучить:**

- Шаблонные строки (`` `${task.text}` ``)
- Динамическое создание элементов (`createElement`)

**Практические задачи:**

1. Сгенерировать HTML для задачи:
   ```html
   <div class="task" data-id="1">
     <input type="checkbox" />
     <span>Купить молоко</span>
     <button class="delete">×</button>
   </div>
   ```

---

## **II. Пошаговые задачи для реализации TaskManager**

### **1. Модель (Model)**

**Что сделать:**

- Хранение массива задач в формате:
  ```javascript
  { id: 1, text: "Задача 1", done: false }
  ```
- Методы:
  - `addTask(text)` — добавление новой задачи
  - `toggleDone(id)` — изменение статуса
  - `deleteTask(id)` — удаление

**Тест:**

1. Создать модель и добавить 3 задачи.
2. Проверить, что `toggleDone` меняет `done` на `true/false`.

---

### **2. Представление (View)**

**Что сделать:**

- `renderTasks()`: Очищает контейнер и рисует все задачи.
- `createTaskElement(task)`: Генерирует HTML для одной задачи.

**Тест:**

1. Заменить `innerHTML` на `createElement` для рендеринга.
2. Проверить, что новые задачи появляются в DOM.

---

### **3. Контроллер (Controller)**

**Что сделать:**

- Инициализация приложения
- Подписка на события:
  - Клик по кнопке "Добавить" → вызов `model.addTask()`
  - Клик по чекбоксу → вызов `model.toggleDone()`
  - Клик по кнопке удаления → `model.deleteTask()`

**Тест:**

1. Привязать кнопку "Добавить" к добавлению задачи.
2. Убедиться, что статус задачи меняется по клику на чекбокс.

---

## **III. Тестовые задачи для отработки**

1. **Добавление задачи**

   - Написать метод `model.addTask("Новая задача")` и проверить, что она появляется в DOM.

2. **Удаление задачи**

   - Реализовать удаление через делегирование событий (клик по кнопке ×).

3. **Переключение статуса**

   - Связать чекбокс с методом `model.toggleDone(id)`.

4. **Локальное хранилище**

   - Сохранять задачи в `localStorage` и загружать при старте.

5. **Фильтрация**
   - Добавить кнопки "Все", "Активные", "Выполненные".

---

## **IV. Дополнительные темы (по желанию)**

- **События клавиатуры**: Добавление задачи по `Enter`.
- **Дебаунс**: Оптимизация поиска по задачам.
- **Drag-and-Drop**: Перетаскивание для изменения порядка.

---

### **2. Работа с данными**

- [ ] Оптимизация и контроль данных: Применение деструктуризации для обработки объектов,Использование дескрипторов для контроля изменения объектов

**План:**

1. Деструктуризация для обработки задач:
   ```javascript
   const { id, text, done } = task;
   ```
2. Защита данных через дескрипторы:
   ```javascript
   Object.defineProperty(task, "id", { writable: false });
   ```

- [ ] Фильтрация задач по статусу (активные/выполненные)

**План:**

1. Реализовать методы:
   ```javascript
   getActiveTasks() {
     return this.tasks.filter(task => !task.done);
   }
   ```
2. Добавить кнопки фильтрации

---

### **3. Сохранение состояния в localStorage**

- [ ] Работа с localStorage + сериализация данных

**План:**

1. Сериализация при изменении:
   ```javascript
   saveTasks() {
     localStorage.setItem('tasks', JSON.stringify(this.tasks));
   }
   ```
2. Загрузка при старте:
   ```javascript
   loadTasks() {
     return JSON.parse(localStorage.getItem('tasks')) || [];
   }
   ```

---

### **4. Оптимизация**

- [ ] Профилирование (замеры времени, анализ перерисовок)

**План:**

1. Замер времени рендеринга:
   ```javascript
   console.time("render");
   renderTasks();
   console.timeEnd("render");
   ```
2. Кеширование DOM-элементов:
   ```javascript
   this.taskList = document.getElementById("task-list");
   ```

**Чекбокс: Дебаунс ввода**

- [ ] Кешировние элементов DOM
- [ ] Оптимизация рендеринга, дебаунс для обработки ввода

**План:**

```javascript
let timeout;
searchInput.addEventListener("input", () => {
  clearTimeout(timeout);
  timeout = setTimeout(() => filterTasks(), 300);
});
```

---

### **5. Расширенные функции: Модульность**

- [ ] Сложность масштабирования: Переход на модульную систему (ES6 Modules + паттерн “Фасад”)

**План:**

1. Разделить на модули:
   ```
   /src
     ├── Task.js        # Класс задачи
     ├── TaskManager.js # Логика
     └── render.js      # Отрисовка
   ```
2. Использовать фасад:
   ```javascript
   export default class TaskFacade {
     constructor() {
       this.manager = new TaskManager();
     }
   }
   ```

- [ ] Валидация: Добавление проверки данных перед введением для устранения ошибок

**План:**

```javascript
addTask(text) {
  if (text.trim().length < 3) {
    showError('Минимум 3 символа');
    return;
  }
}
```

---

- [ ] Дублирование задач: Добавление генерации уникальных id (через Date.now)

**План:**

```javascript
generateId() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2);
}
```

---

### **Последовательность реализации**

1. Базовый рендеринг (DOM)
2. Добавление/удаление задач
3. Фильтрация и поиск
4. Сохранение в localStorage
5. Оптимизация (кеширование, дебаунс)
6. Расширенные функции (валидация, категории)

Для каждой задачи:

- Изучить теорию
- Реализовать минимальную версию
- Протестировать
- Интегрировать в основное приложение

Пример структуры данных задачи:

```javascript
{
  id: 'abc123',
  text: 'Купить молоко',
  done: false,
  category: 'shopping',
  priority: 1
}
```

### User Flow (логика работы)

1.  **Инициализация приложения**

2.  **Главный цикл** (пока пользователь не выйдет):

- 1. Добавить задачу
- 2. Удалить задачу (по ID)
- 3. Редактировать задачу (по ID)
- 4. Отметить как выполненную (по ID)
- 5. Показать все задачи
- 6. Выход
- 7. Выберите действие (1-6):

3.  **Для каждого действия**:
    - Запрашиваются необходимые данные
    - Выполняется соответствующая функция
    - Выводится результат
    - Цикл повторяется

### Оценка (7-10 баллов для след. проекта/темы):

**Работоспособность (4 балла):**

- [ ] Все основные операции работают
- [ ] Нет критических ошибок

**Качество кода (3 балла):**

- [ ] Четкое разделение на модули
- [ ] Нет дублирования кода

**Дополнительные возможности (2 балла)\*:**

- [ ] Реализована фильтрация
- [ ] Есть валидация ввода

**Стиль кода (1 балл):**

- [ ] Единый стиль именования
- [ ] Комментарии для сложных мест
